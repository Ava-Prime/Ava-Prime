import {
  __spreadProps,
  __spreadValues
} from "./chunk-DJRN6NKF.mjs";
import { MetricExporter } from "@google-cloud/opentelemetry-cloud-monitoring-exporter";
import { TraceExporter } from "@google-cloud/opentelemetry-cloud-trace-exporter";
import { GcpDetectorSync } from "@google-cloud/opentelemetry-resource-util";
import { SpanStatusCode, TraceFlags } from "@opentelemetry/api";
import { getNodeAutoInstrumentations } from "@opentelemetry/auto-instrumentations-node";
import { PinoInstrumentation } from "@opentelemetry/instrumentation-pino";
import { WinstonInstrumentation } from "@opentelemetry/instrumentation-winston";
import { Resource } from "@opentelemetry/resources";
import {
  AggregationTemporality,
  DefaultAggregation,
  ExponentialHistogramAggregation,
  InMemoryMetricExporter,
  InstrumentType,
  PeriodicExportingMetricReader
} from "@opentelemetry/sdk-metrics";
import {
  AlwaysOnSampler,
  BatchSpanProcessor,
  InMemorySpanExporter
} from "@opentelemetry/sdk-trace-base";
let metricExporter;
let spanProcessor;
let spanExporter;
class GcpOpenTelemetry {
  constructor(options) {
    /**
     * Log hook for writing trace and span metadata to log messages in the format
     * required by GCP.
     */
    this.gcpTraceLogHook = (span, record) => {
      const isSampled = !!(span.spanContext().traceFlags & TraceFlags.SAMPLED);
      record["logging.googleapis.com/trace"] = `projects/${this.options.projectId}/traces/${span.spanContext().traceId}`;
      record["logging.googleapis.com/spanId"] = span.spanContext().spanId;
      record["logging.googleapis.com/trace_sampled"] = isSampled ? "1" : "0";
    };
    this.options = options || {};
    this.resource = new Resource({ type: "global" }).merge(
      new GcpDetectorSync().detect()
    );
  }
  getConfig() {
    var _a, _b;
    spanProcessor = new BatchSpanProcessor(this.createSpanExporter());
    return {
      resource: this.resource,
      spanProcessor,
      sampler: ((_b = (_a = this.options) == null ? void 0 : _a.telemetryConfig) == null ? void 0 : _b.sampler) || new AlwaysOnSampler(),
      instrumentations: this.getInstrumentations(),
      metricReader: this.createMetricReader()
    };
  }
  createSpanExporter() {
    spanExporter = new AdjustingTraceExporter(
      this.shouldExportTraces() ? new TraceExporter() : new InMemorySpanExporter()
    );
    return spanExporter;
  }
  /**
   * Creates a {MetricReader} for pushing metrics out to GCP via OpenTelemetry.
   */
  createMetricReader() {
    var _a, _b, _c, _d;
    metricExporter = this.buildMetricExporter();
    return new PeriodicExportingMetricReader({
      exportIntervalMillis: ((_b = (_a = this.options) == null ? void 0 : _a.telemetryConfig) == null ? void 0 : _b.metricExportIntervalMillis) || 3e5,
      exportTimeoutMillis: ((_d = (_c = this.options) == null ? void 0 : _c.telemetryConfig) == null ? void 0 : _d.metricExportTimeoutMillis) || 3e5,
      exporter: metricExporter
    });
  }
  /** Gets all open telemetry instrumentations as configured by the plugin. */
  getInstrumentations() {
    var _a, _b, _c, _d;
    if ((_b = (_a = this.options) == null ? void 0 : _a.telemetryConfig) == null ? void 0 : _b.autoInstrumentation) {
      return getNodeAutoInstrumentations(
        ((_d = (_c = this.options) == null ? void 0 : _c.telemetryConfig) == null ? void 0 : _d.autoInstrumentationConfig) || {}
      ).concat(this.getDefaultLoggingInstrumentations());
    }
    return this.getDefaultLoggingInstrumentations();
  }
  shouldExportTraces() {
    var _a, _b;
    return (((_a = this.options.telemetryConfig) == null ? void 0 : _a.forceDevExport) || process.env.GENKIT_ENV !== "dev") && !((_b = this.options.telemetryConfig) == null ? void 0 : _b.disableTraces);
  }
  shouldExportMetrics() {
    var _a, _b;
    return (((_a = this.options.telemetryConfig) == null ? void 0 : _a.forceDevExport) || process.env.GENKIT_ENV !== "dev") && !((_b = this.options.telemetryConfig) == null ? void 0 : _b.disableMetrics);
  }
  /** Always configure the Pino and Winston instrumentations */
  getDefaultLoggingInstrumentations() {
    return [
      new WinstonInstrumentation({ logHook: this.gcpTraceLogHook }),
      new PinoInstrumentation({ logHook: this.gcpTraceLogHook })
    ];
  }
  buildMetricExporter() {
    const exporter = this.shouldExportMetrics() ? new MetricExporter({ projectId: this.options.projectId }) : new InMemoryMetricExporter(AggregationTemporality.DELTA);
    exporter.selectAggregation = (instrumentType) => {
      if (instrumentType === InstrumentType.HISTOGRAM) {
        return new ExponentialHistogramAggregation();
      }
      return new DefaultAggregation();
    };
    exporter.selectAggregationTemporality = (instrumentType) => {
      return AggregationTemporality.DELTA;
    };
    return exporter;
  }
}
class AdjustingTraceExporter {
  constructor(exporter) {
    this.exporter = exporter;
  }
  export(spans, resultCallback) {
    var _a;
    (_a = this.exporter) == null ? void 0 : _a.export(this.adjust(spans), resultCallback);
  }
  shutdown() {
    var _a;
    return (_a = this.exporter) == null ? void 0 : _a.shutdown();
  }
  getExporter() {
    return this.exporter;
  }
  forceFlush() {
    var _a;
    if ((_a = this.exporter) == null ? void 0 : _a.forceFlush) {
      return this.exporter.forceFlush();
    }
    return Promise.resolve();
  }
  adjust(spans) {
    return spans.map((span) => {
      span = this.redactPii(span);
      span = this.markErrorSpanAsError(span);
      span = this.normalizeLabels(span);
      return span;
    });
  }
  redactPii(span) {
    const hasInput = "genkit:input" in span.attributes;
    const hasOutput = "genkit:output" in span.attributes;
    return !hasInput && !hasOutput ? span : __spreadProps(__spreadValues({}, span), {
      spanContext: span.spanContext,
      attributes: __spreadProps(__spreadValues({}, span.attributes), {
        "genkit:input": "<redacted>",
        "genkit:output": "<redacted>"
      })
    });
  }
  // This is a workaround for GCP Trace to mark a span with a red
  // exclamation mark indicating that it is an error.
  markErrorSpanAsError(span) {
    return span.status.code !== SpanStatusCode.ERROR ? span : __spreadProps(__spreadValues({}, span), {
      spanContext: span.spanContext,
      attributes: __spreadProps(__spreadValues({}, span.attributes), {
        "/http/status_code": "599"
      })
    });
  }
  // This is a workaround for GCP Trace to mark a span with a red
  // exclamation mark indicating that it is an error.
  normalizeLabels(span) {
    const normalized = {};
    for (const [key, value] of Object.entries(span.attributes)) {
      normalized[key.replace(/\:/g, "/")] = value;
    }
    return __spreadProps(__spreadValues({}, span), {
      spanContext: span.spanContext,
      attributes: normalized
    });
  }
}
function __getMetricExporterForTesting() {
  return metricExporter;
}
function __getSpanExporterForTesting() {
  return spanExporter.getExporter();
}
function __forceFlushSpansForTesting() {
  spanProcessor.forceFlush();
}
export {
  GcpOpenTelemetry,
  __forceFlushSpansForTesting,
  __getMetricExporterForTesting,
  __getSpanExporterForTesting
};
//# sourceMappingURL=gcpOpenTelemetry.mjs.map