import {
  __async
} from "../chunk-XEFTB2OF.mjs";
import {
  SpanStatusCode,
  trace
} from "@opentelemetry/api";
import { AsyncLocalStorage } from "node:async_hooks";
import { performance } from "node:perf_hooks";
const spanMetadataAls = new AsyncLocalStorage();
const traceMetadataAls = new AsyncLocalStorage();
const ATTR_PREFIX = "genkit";
const SPAN_TYPE_ATTR = ATTR_PREFIX + ":type";
const TRACER_NAME = "genkit-tracer";
const TRACER_VERSION = "v1";
function newTrace(opts, fn) {
  return __async(this, null, function* () {
    const traceMetadata = traceMetadataAls.getStore() || {
      paths: /* @__PURE__ */ new Set(),
      timestamp: performance.now()
    };
    if (opts.labels && opts.labels[SPAN_TYPE_ATTR] === "flow") {
      traceMetadata.flowName = opts.name;
    }
    return yield traceMetadataAls.run(
      traceMetadata,
      () => runInNewSpan(
        {
          metadata: {
            name: opts.name,
            isRoot: true
          },
          labels: opts.labels,
          links: opts.links
        },
        (metadata, otSpan) => __async(this, null, function* () {
          return yield fn(metadata, otSpan);
        })
      )
    );
  });
}
function runInNewSpan(opts, fn) {
  return __async(this, null, function* () {
    const tracer = trace.getTracer(TRACER_NAME, TRACER_VERSION);
    const parentStep = spanMetadataAls.getStore();
    const isInRoot = (parentStep == null ? void 0 : parentStep.isRoot) === true;
    return yield tracer.startActiveSpan(
      opts.metadata.name,
      { links: opts.links },
      (otSpan) => __async(this, null, function* () {
        var _a, _b, _c, _d, _e, _f;
        if (opts.labels)
          otSpan.setAttributes(opts.labels);
        try {
          const parentPath = (parentStep == null ? void 0 : parentStep.path) || "";
          const stepType = opts.labels && opts.labels["genkit:type"] ? `,t:${opts.labels["genkit:type"]}` : "";
          opts.metadata.path = parentPath + `/{${opts.metadata.name}${stepType}}`;
          const pathCount = getCurrentPathCount();
          const output = yield spanMetadataAls.run(
            opts.metadata,
            () => fn(opts.metadata, otSpan, isInRoot)
          );
          if (opts.metadata.state !== "error") {
            opts.metadata.state = "success";
          }
          opts.metadata.path = decoratePathWithSubtype(opts.metadata);
          if (pathCount == getCurrentPathCount()) {
            const now = performance.now();
            const start = ((_a = traceMetadataAls.getStore()) == null ? void 0 : _a.timestamp) || now;
            (_c = (_b = traceMetadataAls.getStore()) == null ? void 0 : _b.paths) == null ? void 0 : _c.add({
              path: opts.metadata.path,
              status: "success",
              latency: now - start
            });
          }
          return output;
        } catch (e) {
          opts.metadata.path = decoratePathWithSubtype(opts.metadata);
          const now = performance.now();
          const start = ((_d = traceMetadataAls.getStore()) == null ? void 0 : _d.timestamp) || now;
          (_f = (_e = traceMetadataAls.getStore()) == null ? void 0 : _e.paths) == null ? void 0 : _f.add({
            path: opts.metadata.path,
            status: "failure",
            error: e.name,
            latency: now - start
          });
          opts.metadata.state = "error";
          otSpan.setStatus({
            code: SpanStatusCode.ERROR,
            message: getErrorMessage(e)
          });
          if (e instanceof Error) {
            otSpan.recordException(e);
          }
          throw e;
        } finally {
          otSpan.setAttributes(metadataToAttributes(opts.metadata));
          otSpan.end();
        }
      })
    );
  });
}
function getErrorMessage(e) {
  if (e instanceof Error) {
    return e.message;
  }
  return `${e}`;
}
function metadataToAttributes(metadata) {
  const out = {};
  Object.keys(metadata).forEach((key) => {
    if (key === "metadata" && typeof metadata[key] === "object" && metadata.metadata) {
      Object.entries(metadata.metadata).forEach(([metaKey, value]) => {
        out[ATTR_PREFIX + ":metadata:" + metaKey] = value;
      });
    } else if (key === "input" || typeof metadata[key] === "object") {
      out[ATTR_PREFIX + ":" + key] = JSON.stringify(metadata[key]);
    } else {
      out[ATTR_PREFIX + ":" + key] = metadata[key];
    }
  });
  return out;
}
function setCustomMetadataAttribute(key, value) {
  const currentStep = getCurrentSpan();
  if (!currentStep) {
    return;
  }
  if (!currentStep.metadata) {
    currentStep.metadata = {};
  }
  currentStep.metadata[key] = value;
}
function setCustomMetadataAttributes(values) {
  const currentStep = getCurrentSpan();
  if (!currentStep) {
    return;
  }
  if (!currentStep.metadata) {
    currentStep.metadata = {};
  }
  for (const [key, value] of Object.entries(values)) {
    currentStep.metadata[key] = value;
  }
}
function toDisplayPath(path) {
  const pathPartRegex = /\{([^\,}]+),[^\}]+\}/g;
  return Array.from(path.matchAll(pathPartRegex), (m) => m[1]).join(" > ");
}
function getCurrentSpan() {
  const step = spanMetadataAls.getStore();
  if (!step) {
    throw new Error("running outside step context");
  }
  return step;
}
function getCurrentPathCount() {
  var _a, _b;
  return ((_b = (_a = traceMetadataAls.getStore()) == null ? void 0 : _a.paths) == null ? void 0 : _b.size) || 0;
}
function decoratePathWithSubtype(metadata) {
  var _a;
  if (!metadata.path) {
    return "";
  }
  const pathComponents = metadata.path.split("}/{");
  if (pathComponents.length == 1) {
    return metadata.path;
  }
  const stepSubtype = metadata.metadata && metadata.metadata["subtype"] ? `,s:${metadata.metadata["subtype"]}` : "";
  const root = `${pathComponents.slice(0, -1).join("}/{")}}/`;
  const decoratedStep = `{${(_a = pathComponents.at(-1)) == null ? void 0 : _a.slice(0, -1)}${stepSubtype}}`;
  return root + decoratedStep;
}
export {
  ATTR_PREFIX,
  SPAN_TYPE_ATTR,
  newTrace,
  runInNewSpan,
  setCustomMetadataAttribute,
  setCustomMetadataAttributes,
  spanMetadataAls,
  toDisplayPath,
  traceMetadataAls
};
//# sourceMappingURL=instrumentation.mjs.map